{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.teardown = teardown;\nexports.isFocusVisible = isFocusVisible;\nexports.handleBlurVisible = handleBlurVisible;\nexports.initFocusVisible = initFocusVisible;\nexports.forkBlur = exports.forkFocus = void 0;\n\n/*\nCopyright (c) Uber Technologies, Inc.\n\nThis source code is licensed under the MIT license found in the\nLICENSE file in the root directory of this source tree.\n*/\n// based on:\n// - https://github.com/mui-org/material-ui/blob/master/packages/material-ui/src/utils/focusVisible.js\n// - https://github.com/WICG/focus-visible/blob/v4.1.5/src/focus-visible.js\nvar initialized = false;\nvar hadKeyboardEvent = true;\nvar hadFocusVisibleRecently = false;\nvar hadFocusVisibleRecentlyTimeout = null;\nvar inputTypesWhitelist = {\n  text: true,\n  search: true,\n  url: true,\n  tel: true,\n  email: true,\n  password: true,\n  number: true,\n  date: true,\n  month: true,\n  week: true,\n  time: true,\n  datetime: true,\n  'datetime-local': true\n};\n/**\n * Computes whether the given element should automatically trigger the\n * `focus-visible` class being added, i.e. whether it should always match\n * `:focus-visible` when focused.\n * @param {Element} node\n * @return {boolean}\n */\n\nfunction focusTriggersKeyboardModality(node) {\n  var type = node.type,\n    tagName = node.tagName;\n  if (tagName === 'INPUT' && inputTypesWhitelist[type] && !node.readOnly) {\n    return true;\n  }\n  if (tagName === 'TEXTAREA' && !node.readOnly) {\n    return true;\n  }\n  if (node.isContentEditable) {\n    return true;\n  }\n  return false;\n}\n/**\n * Keep track of our keyboard modality state with `hadKeyboardEvent`.\n * If the most recent user interaction was via the keyboard;\n * and the key press did not include a meta, alt/option, or control key;\n * then the modality is keyboard. Otherwise, the modality is not keyboard.\n * @param {KeyboardEvent} event\n */\n\nfunction handleKeyDown(event) {\n  if (event.metaKey || event.altKey || event.ctrlKey) {\n    return;\n  }\n  hadKeyboardEvent = true;\n}\n/**\n * If at any point a user clicks with a pointing device, ensure that we change\n * the modality away from keyboard.\n * This avoids the situation where a user presses a key on an already focused\n * element, and then clicks on a different element, focusing it with a\n * pointing device, while we still think we're in keyboard modality.\n */\n\nfunction handlePointerDown() {\n  hadKeyboardEvent = false;\n}\nfunction handleVisibilityChange() {\n  if (this.visibilityState === 'hidden') {\n    // If the tab becomes active again, the browser will handle calling focus\n    // on the element (Safari actually calls it twice).\n    // If this tab change caused a blur on an element with focus-visible,\n    // re-apply the class when the user switches back to the tab.\n    if (hadFocusVisibleRecently) {\n      hadKeyboardEvent = true;\n    }\n  }\n}\nfunction prepare(doc) {\n  doc.addEventListener('keydown', handleKeyDown, true);\n  doc.addEventListener('mousedown', handlePointerDown, true);\n  doc.addEventListener('pointerdown', handlePointerDown, true);\n  doc.addEventListener('touchstart', handlePointerDown, true);\n  doc.addEventListener('visibilitychange', handleVisibilityChange, true);\n} //$FlowFixMe\n\nfunction teardown(doc) {\n  doc.removeEventListener('keydown', handleKeyDown, true);\n  doc.removeEventListener('mousedown', handlePointerDown, true);\n  doc.removeEventListener('pointerdown', handlePointerDown, true);\n  doc.removeEventListener('touchstart', handlePointerDown, true);\n  doc.removeEventListener('visibilitychange', handleVisibilityChange, true);\n} //$FlowFixMe\n\nfunction isFocusVisible(event) {\n  try {\n    return event.target.matches(':focus-visible');\n  } catch (error) {// browsers not implementing :focus-visible will throw a SyntaxError\n    // we use our own heuristic for those browsers\n    // rethrow might be better if it's not the expected error but do we really\n    // want to crash if focus-visible malfunctioned?\n  } // no need for validFocusTarget check. the user does that by attaching it to\n  // focusable events only\n\n  return hadKeyboardEvent || focusTriggersKeyboardModality(event.target);\n}\n/**\n * Should be called if a blur event is fired on a focus-visible element\n */\n\nfunction handleBlurVisible() {\n  // To detect a tab/window switch, we look for a blur event followed\n  // rapidly by a visibility change.\n  // If we don't see a visibility change within 100ms, it's probably a\n  // regular focus change.\n  hadFocusVisibleRecently = true;\n  if (typeof document !== 'undefined') {\n    window.clearTimeout(hadFocusVisibleRecentlyTimeout);\n    hadFocusVisibleRecentlyTimeout = window.setTimeout(function () {\n      hadFocusVisibleRecently = false;\n    }, 100);\n  }\n} //$FlowFixMe\n\nfunction initFocusVisible(node) {\n  if (!initialized && node != null) {\n    initialized = true;\n    prepare(node.ownerDocument);\n  }\n}\nvar forkFocus = function forkFocus(rootProps, handler) {\n  return function (e) {\n    if (typeof rootProps.onFocus === 'function') {\n      rootProps.onFocus(e);\n    }\n    handler(e);\n  };\n};\nexports.forkFocus = forkFocus;\nvar forkBlur = function forkBlur(rootProps, handler) {\n  return function (e) {\n    if (typeof rootProps.onBlur === 'function') {\n      rootProps.onBlur(e);\n    }\n    handler(e);\n  };\n};\nexports.forkBlur = forkBlur;","map":{"version":3,"names":["Object","defineProperty","exports","value","teardown","isFocusVisible","handleBlurVisible","initFocusVisible","forkBlur","forkFocus","initialized","hadKeyboardEvent","hadFocusVisibleRecently","hadFocusVisibleRecentlyTimeout","inputTypesWhitelist","text","search","url","tel","email","password","number","date","month","week","time","datetime","focusTriggersKeyboardModality","node","type","tagName","readOnly","isContentEditable","handleKeyDown","event","metaKey","altKey","ctrlKey","handlePointerDown","handleVisibilityChange","visibilityState","prepare","doc","addEventListener","removeEventListener","target","matches","error","document","window","clearTimeout","setTimeout","ownerDocument","rootProps","handler","e","onFocus","onBlur"],"sources":["D:/My CodeBase/Web Development/DebugBeast Portfolio/node_modules/baseui/utils/focusVisible.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.teardown = teardown;\nexports.isFocusVisible = isFocusVisible;\nexports.handleBlurVisible = handleBlurVisible;\nexports.initFocusVisible = initFocusVisible;\nexports.forkBlur = exports.forkFocus = void 0;\n\n/*\nCopyright (c) Uber Technologies, Inc.\n\nThis source code is licensed under the MIT license found in the\nLICENSE file in the root directory of this source tree.\n*/\n// based on:\n// - https://github.com/mui-org/material-ui/blob/master/packages/material-ui/src/utils/focusVisible.js\n// - https://github.com/WICG/focus-visible/blob/v4.1.5/src/focus-visible.js\nvar initialized = false;\nvar hadKeyboardEvent = true;\nvar hadFocusVisibleRecently = false;\nvar hadFocusVisibleRecentlyTimeout = null;\nvar inputTypesWhitelist = {\n  text: true,\n  search: true,\n  url: true,\n  tel: true,\n  email: true,\n  password: true,\n  number: true,\n  date: true,\n  month: true,\n  week: true,\n  time: true,\n  datetime: true,\n  'datetime-local': true\n};\n/**\n * Computes whether the given element should automatically trigger the\n * `focus-visible` class being added, i.e. whether it should always match\n * `:focus-visible` when focused.\n * @param {Element} node\n * @return {boolean}\n */\n\nfunction focusTriggersKeyboardModality(node) {\n  var type = node.type,\n      tagName = node.tagName;\n\n  if (tagName === 'INPUT' && inputTypesWhitelist[type] && !node.readOnly) {\n    return true;\n  }\n\n  if (tagName === 'TEXTAREA' && !node.readOnly) {\n    return true;\n  }\n\n  if (node.isContentEditable) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * Keep track of our keyboard modality state with `hadKeyboardEvent`.\n * If the most recent user interaction was via the keyboard;\n * and the key press did not include a meta, alt/option, or control key;\n * then the modality is keyboard. Otherwise, the modality is not keyboard.\n * @param {KeyboardEvent} event\n */\n\n\nfunction handleKeyDown(event) {\n  if (event.metaKey || event.altKey || event.ctrlKey) {\n    return;\n  }\n\n  hadKeyboardEvent = true;\n}\n/**\n * If at any point a user clicks with a pointing device, ensure that we change\n * the modality away from keyboard.\n * This avoids the situation where a user presses a key on an already focused\n * element, and then clicks on a different element, focusing it with a\n * pointing device, while we still think we're in keyboard modality.\n */\n\n\nfunction handlePointerDown() {\n  hadKeyboardEvent = false;\n}\n\nfunction handleVisibilityChange() {\n  if (this.visibilityState === 'hidden') {\n    // If the tab becomes active again, the browser will handle calling focus\n    // on the element (Safari actually calls it twice).\n    // If this tab change caused a blur on an element with focus-visible,\n    // re-apply the class when the user switches back to the tab.\n    if (hadFocusVisibleRecently) {\n      hadKeyboardEvent = true;\n    }\n  }\n}\n\nfunction prepare(doc) {\n  doc.addEventListener('keydown', handleKeyDown, true);\n  doc.addEventListener('mousedown', handlePointerDown, true);\n  doc.addEventListener('pointerdown', handlePointerDown, true);\n  doc.addEventListener('touchstart', handlePointerDown, true);\n  doc.addEventListener('visibilitychange', handleVisibilityChange, true);\n} //$FlowFixMe\n\n\nfunction teardown(doc) {\n  doc.removeEventListener('keydown', handleKeyDown, true);\n  doc.removeEventListener('mousedown', handlePointerDown, true);\n  doc.removeEventListener('pointerdown', handlePointerDown, true);\n  doc.removeEventListener('touchstart', handlePointerDown, true);\n  doc.removeEventListener('visibilitychange', handleVisibilityChange, true);\n} //$FlowFixMe\n\n\nfunction isFocusVisible(event) {\n  try {\n    return event.target.matches(':focus-visible');\n  } catch (error) {// browsers not implementing :focus-visible will throw a SyntaxError\n    // we use our own heuristic for those browsers\n    // rethrow might be better if it's not the expected error but do we really\n    // want to crash if focus-visible malfunctioned?\n  } // no need for validFocusTarget check. the user does that by attaching it to\n  // focusable events only\n\n\n  return hadKeyboardEvent || focusTriggersKeyboardModality(event.target);\n}\n/**\n * Should be called if a blur event is fired on a focus-visible element\n */\n\n\nfunction handleBlurVisible() {\n  // To detect a tab/window switch, we look for a blur event followed\n  // rapidly by a visibility change.\n  // If we don't see a visibility change within 100ms, it's probably a\n  // regular focus change.\n  hadFocusVisibleRecently = true;\n\n  if (typeof document !== 'undefined') {\n    window.clearTimeout(hadFocusVisibleRecentlyTimeout);\n    hadFocusVisibleRecentlyTimeout = window.setTimeout(function () {\n      hadFocusVisibleRecently = false;\n    }, 100);\n  }\n} //$FlowFixMe\n\n\nfunction initFocusVisible(node) {\n  if (!initialized && node != null) {\n    initialized = true;\n    prepare(node.ownerDocument);\n  }\n}\n\nvar forkFocus = function forkFocus(rootProps, handler) {\n  return function (e) {\n    if (typeof rootProps.onFocus === 'function') {\n      rootProps.onFocus(e);\n    }\n\n    handler(e);\n  };\n};\n\nexports.forkFocus = forkFocus;\n\nvar forkBlur = function forkBlur(rootProps, handler) {\n  return function (e) {\n    if (typeof rootProps.onBlur === 'function') {\n      rootProps.onBlur(e);\n    }\n\n    handler(e);\n  };\n};\n\nexports.forkBlur = forkBlur;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}